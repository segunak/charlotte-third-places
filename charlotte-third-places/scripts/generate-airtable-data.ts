/**
 * Build-time script to generate entity data from Airtable.
 *
 * This script fetches all places from Airtable (production) or local CSV (development)
 * and extracts distinct neighborhoods and tags for use in entity detection during
 * RAG query processing.
 *
 * The generated file is used by the AI chatbot to detect when users mention specific
 * neighborhoods or tags, enabling more precise filtering before vector search.
 *
 * Usage:
 *   npm run generate-airtable-data
 *
 * This runs automatically as a prebuild step before `next build`.
 */

import fs from "fs";
import path from "path";
import Airtable from "airtable";
import csvParser from "csv-parser";
import stripBomStream from "strip-bom-stream";

// Output file path (relative to this script's location)
const OUTPUT_PATH = path.resolve(__dirname, "../lib/ai/airtable-generated-data.ts");

/**
 * Creates an Airtable base instance.
 * Only called when we actually need to fetch from Airtable (not local CSV).
 */
function getAirtableBase() {
  return new Airtable({
    apiKey: process.env.AIRTABLE_PERSONAL_ACCESS_TOKEN,
  }).base("apptV6h58vA4jhWFg");
}

/**
 * Determines whether to use local data or production data.
 * Same logic as data-services.ts.
 */
const shouldUseLocalData = (): boolean => {
  if (process.env.FORCE_PRODUCTION_DATA === "true") {
    console.log("Info: Using production data (forced via FORCE_PRODUCTION_DATA).");
    return false;
  }

  if (process.env.NODE_ENV === "development") {
    console.log("Info: Local development mode. Using CSV data for generation.");
    return true;
  }

  // When running as a prebuild script, NODE_ENV isn't set, so check for Airtable token
  if (!process.env.AIRTABLE_PERSONAL_ACCESS_TOKEN) {
    console.log("Info: No Airtable token found. Using CSV data for generation.");
    return true;
  }

  return false;
};

interface PlaceRecord {
  neighborhood: string;
  tags: string[];
}

/**
 * Reads places from local CSV file.
 */
async function getPlacesFromCSV(filePath: string): Promise<PlaceRecord[]> {
  const localDataPath = path.resolve(filePath);
  const places: PlaceRecord[] = [];

  return new Promise((resolve, reject) => {
    fs.createReadStream(localDataPath)
      .pipe(stripBomStream())
      .pipe(csvParser())
      .on("data", (row) => {
        try {
          // Parse tags from comma-separated string
          const tags = row["Tags"]
            ? row["Tags"]
                .split(",")
                .map((t: string) => t.trim())
                .filter((t: string) => t.length > 0)
            : [];

          places.push({
            neighborhood: row["Neighborhood"] || "",
            tags,
          });
        } catch (error) {
          console.warn(`Failed to parse row: ${JSON.stringify(row)}. Error: ${error}`);
        }
      })
      .on("end", () => resolve(places))
      .on("error", (error) => reject(error));
  });
}

/**
 * Fetches places from Airtable.
 */
async function getPlacesFromAirtable(): Promise<PlaceRecord[]> {
  const base = getAirtableBase();
  const records = await base("Charlotte Third Places").select({ view: "Production" }).all();

  return records.map((record) => ({
    neighborhood: (record.get("Neighborhood") as string) || "",
    tags: (record.get("Tags") as string[]) || [],
  }));
}

/**
 * Main generation function.
 */
async function generateEntityData() {
  console.log("\n═══════════════════════════════════════════════════════════════════");
  console.log("  Generating Airtable Entity Data");
  console.log("═══════════════════════════════════════════════════════════════════\n");

  // Fetch places
  let places: PlaceRecord[];

  if (shouldUseLocalData()) {
    places = await getPlacesFromCSV("./local-data/Charlotte Third Places-Production.csv");
  } else {
    places = await getPlacesFromAirtable();
  }

  console.log(`Fetched ${places.length} places.`);

  // Extract distinct neighborhoods (filter empty, sort alphabetically)
  const neighborhoods = [...new Set(places.map((p) => p.neighborhood).filter((n) => n.length > 0))].sort();

  console.log(`Found ${neighborhoods.length} distinct neighborhoods.`);

  // Extract distinct tags (filter empty, sort alphabetically)
  const tags = [...new Set(places.flatMap((p) => p.tags).filter((t) => t.length > 0))].sort();

  console.log(`Found ${tags.length} distinct tags.`);

  // Generate the TypeScript file content
  const generatedAt = new Date().toISOString();
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is generated by scripts/generate-airtable-data.ts
 * Run: npm run generate-airtable-data
 *
 * Generated at: ${generatedAt}
 *
 * Contains distinct neighborhoods and tags from Airtable for entity detection
 * in the RAG query pipeline. These values are used to detect when users mention
 * specific neighborhoods or tags, enabling more precise filtering.
 */

/**
 * All distinct neighborhoods from Airtable.
 * Used by detectNeighborhoods() in entity-detection.ts.
 */
export const NEIGHBORHOODS = [
${neighborhoods.map((n) => `  "${n}",`).join("\n")}
] as const;

export type Neighborhood = (typeof NEIGHBORHOODS)[number];

/**
 * All distinct tags from Airtable.
 * Used by detectTags() in entity-detection.ts.
 */
export const TAGS = [
${tags.map((t) => `  "${t}",`).join("\n")}
] as const;

export type Tag = (typeof TAGS)[number];
`;

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write the file
  fs.writeFileSync(OUTPUT_PATH, content, "utf-8");

  console.log(`\nGenerated: ${OUTPUT_PATH}`);
  console.log("\n═══════════════════════════════════════════════════════════════════");
  console.log("  Generation Complete!");
  console.log("═══════════════════════════════════════════════════════════════════\n");
}

// Run the script
generateEntityData().catch((error) => {
  console.error("Failed to generate entity data:", error);
  process.exit(1);
});
